import axios from 'axios';
import dotenv from 'dotenv';

// Load environment variables from .env file
dotenv.config();

// Regex pattern for parsing ASN numbers from names
const ASN_PATTERN = /AS(\d+)/gi;

// Marker to identify auto-generated content in notes
const AUTO_COMMENT_START = '--- AUTO-GENERATED ---';
const AUTO_COMMENT_END = '--- END AUTO-GENERATED ---';

// Maximum length for notes field (Firewalla API limit)
const MAX_NOTES_LENGTH = 256;

// Ellipsis to indicate truncated content
const TRUNCATION_ELLIPSIS = '...';

// Cache for BGP table data to avoid re-downloading
let bgpTableCache: string | null = null;
let bgpTableCacheTime = 0;
const CACHE_TTL = 3600000; // 1 hour in milliseconds

// Cache for ASNs CSV data to avoid re-downloading
let asnsCache: Map<number, ASNMetadata> | null = null;
let asnsCacheTime = 0;
const ASNS_CACHE_TTL = 86400000; // 24 hours in milliseconds

interface Box {
  gid: string;
  model: string;
  name: string;
  mode: string;
  online: boolean;
  version: string;
  license: string;
  publicIP: string;
  location: string;
  lastSeen: number;
  group: string | null;
  deviceCount: number;
  ruleCount: number;
  alarmCount: number;
}

interface TargetList {
  id: string;
  name: string;
  owner: string;
  targets: string[];
  category?: string;
  notes?: string;
  lastUpdated: number;
  count?: number;
}

interface ASNInfo {
  asn: number;
  prefixes: string[];
  orgName: string;
  countryCode: string;
}

interface ASNMetadata {
  asn: number;
  name: string;
  description: string;
  countryCode: string;
}

interface BGPToolsTableEntry {
  CIDR: string;
  ASN: number;
  CountryCode: string;
  Description: string;
}

/**
 * Parse ASN numbers from a target list name
 * Example: "AS288" -> [288]
 * Example: "AS288, AS565, AS5677" -> [288, 565, 5677]
 * Example: "ACME CORP: AS656" -> [656]
 * Example: "AS656, ACME CORP" -> [656]
 */
function parseASNsFromName(name: string): number[] {
  const asns: number[] = [];
  let match: RegExpExecArray | null;

  // Reset lastIndex in case the regex was used elsewhere
  ASN_PATTERN.lastIndex = 0;

  match = ASN_PATTERN.exec(name);
  while (match !== null) {
    const asn = Number.parseInt(match[1], 10);
    if (!Number.isNaN(asn)) {
      asns.push(asn);
    }
    match = ASN_PATTERN.exec(name);
  }

  return asns;
}

/**
 * Extract user comments from existing notes by removing auto-generated content
 * Returns the user's comments without the auto-generated section
 */
function extractUserComments(notes: string | undefined): string {
  if (!notes) return '';

  const startIndex = notes.indexOf(AUTO_COMMENT_START);
  if (startIndex === -1) {
    // No auto-generated content found, return all as user comments
    return notes.trim();
  }

  const endIndex = notes.indexOf(AUTO_COMMENT_END, startIndex);
  if (endIndex === -1) {
    // Start marker found but no end marker, take content before start marker
    return notes.substring(0, startIndex).trim();
  }

  // Remove the auto-generated section
  const before = notes.substring(0, startIndex).trim();
  const after = notes.substring(endIndex + AUTO_COMMENT_END.length).trim();

  // Combine before and after, filtering out empty strings
  return [before, after].filter((s) => s.length > 0).join('\n\n');
}

/**
 * Truncate notes to fit within the maximum length allowed by Firewalla API
 * Ensures the truncated notes don't exceed MAX_NOTES_LENGTH characters
 */
function truncateNotes(notes: string): string {
  if (notes.length <= MAX_NOTES_LENGTH) {
    return notes;
  }

  // Truncate and add ellipsis, ensuring we don't exceed MAX_NOTES_LENGTH
  const truncateAt = MAX_NOTES_LENGTH - TRUNCATION_ELLIPSIS.length;
  return notes.substring(0, truncateAt) + TRUNCATION_ELLIPSIS;
}

/**
 * Combine user comments with auto-generated content, prioritizing user comments
 * If adding auto-generated content would exceed the limit, only user comments are returned
 * User comments are always preserved and may be truncated if they alone exceed the limit
 */
function combineNotesWithPriority(userComments: string, autoGeneratedContent: string): string {
  // First, ensure user comments fit within the limit
  const truncatedUserComments = truncateNotes(userComments);

  // If there are no user comments, just return auto-generated content (truncated if needed)
  if (!truncatedUserComments) {
    return truncateNotes(autoGeneratedContent);
  }

  // Try to combine user comments with auto-generated content
  const combined = `${truncatedUserComments}\n\n${autoGeneratedContent}`;

  // If combined length fits, return it
  if (combined.length <= MAX_NOTES_LENGTH) {
    return combined;
  }

  // If combined exceeds limit, only return user comments (already truncated)
  return truncatedUserComments;
}

/**
 * Download and cache the BGP table from bgp.tools
 *
 * IMPORTANT: bgp.tools API Requirements
 * - You MUST set a descriptive HTTP User-Agent to identify yourself
 * - Default or generic user agents are NOT supported and may be blocked
 * - Preferred format: "organization bgp.tools - contact@email.com"
 * - Example: "acmeco bgp.tools - contact@acme.co"
 * - Users who scrape HTML pages (not API) may be banned without notice
 * - See: https://bgp.tools/kb/api
 */
async function downloadBGPTable(): Promise<string | null> {
  const now = Date.now();

  // Return cached data if still valid
  if (bgpTableCache !== null && now - bgpTableCacheTime < CACHE_TTL) {
    console.log('  Using cached BGP table data');
    return bgpTableCache;
  }

  try {
    console.log('  Downloading BGP table from bgp.tools...');

    // Get user agent from environment variable (required)
    const userAgent = process.env.BGP_TOOLS_USER_AGENT;
    if (!userAgent) {
      throw new Error('BGP_TOOLS_USER_AGENT environment variable is required');
    }

    const response = await axios.get('https://bgp.tools/table.jsonl', {
      responseType: 'text',
      timeout: 60000, // Increased timeout to 60 seconds
      maxContentLength: 100 * 1024 * 1024, // 100MB limit
      headers: {
        'User-Agent': userAgent,
      },
    });

    if (!response.data) {
      throw new Error('BGP table download returned no data');
    }

    if (typeof response.data !== 'string') {
      throw new Error('BGP table data is not a string');
    }

    bgpTableCache = response.data;
    bgpTableCacheTime = now;

    console.log(`  Downloaded ${(response.data.length / 1024 / 1024).toFixed(2)} MB`);
    return bgpTableCache;
  } catch (error) {
    console.error('  Error downloading BGP table:', error);
    if (axios.isAxiosError(error)) {
      if (error.response) {
        console.error(`  HTTP ${error.response.status}: ${error.response.statusText}`);
        if (error.response.data) {
          console.error(`  Response: ${String(error.response.data).substring(0, 200)}`);
        }
      } else if (error.request) {
        console.error('  No response received from bgp.tools');
      } else {
        console.error(`  Request setup error: ${error.message}`);
      }
    }
    throw new Error(`Failed to download BGP table: ${error}`);
  }
}

/**
 * Download and cache the ASNs CSV from bgp.tools
 * CSV format: ASN,Name,Description,CountryCode
 *
 * IMPORTANT: bgp.tools API Requirements
 * - You MUST set a descriptive HTTP User-Agent to identify yourself
 * - Default or generic user agents are NOT supported and may be blocked
 * - Preferred format: "organization bgp.tools - contact@email.com"
 * - Example: "acmeco bgp.tools - contact@acme.co"
 * - Users who scrape HTML pages (not API) may be banned without notice
 * - See: https://bgp.tools/kb/api
 */
async function downloadASNsData(): Promise<Map<number, ASNMetadata> | null> {
  const now = Date.now();

  // Return cached data if still valid
  if (asnsCache !== null && now - asnsCacheTime < ASNS_CACHE_TTL) {
    console.log('  Using cached ASNs data');
    return asnsCache;
  }

  try {
    console.log('  Downloading ASNs data from bgp.tools...');

    // Get user agent from environment variable (required)
    const userAgent = process.env.BGP_TOOLS_USER_AGENT;
    if (!userAgent) {
      throw new Error('BGP_TOOLS_USER_AGENT environment variable is required');
    }

    const response = await axios.get('https://bgp.tools/asns.csv', {
      responseType: 'text',
      timeout: 60000, // 60 seconds timeout
      maxContentLength: 10 * 1024 * 1024, // 10MB limit
      headers: {
        'User-Agent': userAgent,
      },
    });

    if (!response.data) {
      throw new Error('ASNs CSV download returned no data');
    }

    if (typeof response.data !== 'string') {
      throw new Error('ASNs CSV data is not a string');
    }

    // Parse CSV data into a Map for fast lookups
    const asnsMap = new Map<number, ASNMetadata>();
    const lines = response.data.split('\n');

    // Skip header line and process data
    for (let i = 1; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line) continue;

      // Simple CSV parser that handles quoted fields
      // CSV format: ASN,Name,Description,CountryCode
      const fields: string[] = [];
      let current = '';
      let inQuotes = false;

      for (let j = 0; j < line.length; j++) {
        const char = line[j];

        if (char === '"') {
          inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
          fields.push(current.trim());
          current = '';
        } else {
          current += char;
        }
      }
      fields.push(current.trim()); // Add the last field

      if (fields.length >= 4) {
        const asnStr = fields[0];
        const asn = Number.parseInt(asnStr, 10);

        if (!Number.isNaN(asn)) {
          asnsMap.set(asn, {
            asn,
            name: fields[1],
            description: fields[2],
            countryCode: fields[3],
          });
        }
      }
    }

    asnsCache = asnsMap;
    asnsCacheTime = now;

    console.log(`  Downloaded and parsed ${asnsMap.size} ASN records`);
    return asnsCache;
  } catch (error) {
    console.error('  Error downloading ASNs data:', error);
    if (axios.isAxiosError(error)) {
      if (error.response) {
        console.error(`  HTTP ${error.response.status}: ${error.response.statusText}`);
        if (error.response.data) {
          console.error(`  Response: ${String(error.response.data).substring(0, 200)}`);
        }
      } else if (error.request) {
        console.error('  No response received from bgp.tools');
      } else {
        console.error(`  Request setup error: ${error.message}`);
      }
    }
    // Return null on error but don't throw - we can still continue with Unknown names
    console.warn('  Continuing without ASN metadata...');
    return null;
  }
}

/**
 * Fetch IP prefixes and organization info for a given ASN using BGP.tools data
 */
async function fetchPrefixesForASN(
  asn: number,
  bgpTableData: string,
  asnsData: Map<number, ASNMetadata> | null
): Promise<ASNInfo> {
  console.log(`  Fetching prefixes for AS${asn}...`);

  const prefixes: string[] = [];
  const lines = bgpTableData.split('\n');

  // Extract prefixes from BGP table
  for (const line of lines) {
    if (!line.trim()) continue;

    try {
      const entry: BGPToolsTableEntry = JSON.parse(line);
      if (entry.ASN === asn && entry.CIDR) {
        prefixes.push(entry.CIDR);
      }
    } catch {
      // Skip invalid JSON lines
    }
  }

  // Get organization name and country code from ASNs data
  let orgName = 'Unknown';
  let countryCode = 'Unknown';

  if (asnsData?.has(asn)) {
    const asnMetadata = asnsData.get(asn);
    if (asnMetadata) {
      // Use name and description together for better identification
      orgName = asnMetadata.name || asnMetadata.description || 'Unknown';
      countryCode = asnMetadata.countryCode || 'Unknown';
    }
  }

  console.log(`  Found ${prefixes.length} prefixes for AS${asn}`);
  return {
    asn,
    prefixes,
    orgName,
    countryCode,
  };
}

/**
 * Fetch all Firewalla boxes in the account
 */
async function fetchBoxes(mspDomain: string, token: string): Promise<Box[]> {
  try {
    const response = await axios.get<Box[]>(`https://${mspDomain}/v2/boxes`, {
      headers: {
        Authorization: `Token ${token}`,
      },
    });

    return response.data;
  } catch (error) {
    console.error('Error fetching boxes:', error);
    throw error;
  }
}

/**
 * Fetch all target lists from Firewalla API
 * If owner is provided, fetches target lists for that owner (global or box gid)
 */
async function fetchTargetLists(
  mspDomain: string,
  token: string,
  owner?: string
): Promise<TargetList[]> {
  try {
    const url = owner
      ? `https://${mspDomain}/v2/target-lists?owner=${owner}`
      : `https://${mspDomain}/v2/target-lists`;

    const response = await axios.get<TargetList[]>(url, {
      headers: {
        Authorization: `Token ${token}`,
      },
    });

    return response.data;
  } catch (error) {
    console.error(`Error fetching target lists${owner ? ` for owner ${owner}` : ''}:`, error);
    throw error;
  }
}

/**
 * Update a target list with new targets
 */
async function updateTargetList(
  mspDomain: string,
  token: string,
  listId: string,
  targets: string[],
  notes: string
): Promise<void> {
  try {
    await axios.patch(
      `https://${mspDomain}/v2/target-lists/${listId}`,
      {
        targets,
        notes,
      },
      {
        headers: {
          Authorization: `Token ${token}`,
        },
      }
    );

    console.log(`  ✓ Updated target list ${listId}`);
  } catch (error) {
    console.error(`  Error updating target list ${listId}:`, error);
    throw error;
  }
}

/**
 * Parse command-line arguments
 */
function parseArguments(): { dryRun: boolean; help: boolean } {
  const args = process.argv.slice(2);
  let dryRun = false;
  let help = false;

  for (const arg of args) {
    if (arg === '--dry-run' || arg === '-d') {
      dryRun = true;
    } else if (arg === '--help' || arg === '-h') {
      help = true;
    } else {
      console.error(`Unknown argument: ${arg}`);
      console.error('Valid options are: --dry-run, -d, --help, -h');
      process.exit(1);
    }
  }

  return { dryRun, help };
}

/**
 * Display help message
 */
function showHelp(): void {
  console.log(`
Firewalla ASN Target List Updater

Updates Firewalla target lists with IP prefixes from Autonomous System Numbers (ASNs).

USAGE:
  asn-updater [OPTIONS]

OPTIONS:
  --dry-run, -d    Preview changes without updating target lists
  --help, -h       Show this help message

ENVIRONMENT VARIABLES:
  MSP_DOMAIN              Your Firewalla MSP domain (e.g., mydomain.firewalla.net)
  FIREWALLA_TOKEN         Your Firewalla API personal access token
  BGP_TOOLS_USER_AGENT    User-Agent for bgp.tools API (required)
                          Format: "organization bgp.tools - contact@email.com"
                          Example: "acmeco bgp.tools - contact@acme.co"

EXAMPLES:
  # Run with environment variables
  MSP_DOMAIN=mydomain.firewalla.net FIREWALLA_TOKEN=token \\
    BGP_TOOLS_USER_AGENT="acmeco bgp.tools - contact@acme.co" asn-updater

  # Preview changes without updating
  asn-updater --dry-run

  # Use .env file for environment variables (recommended)
  cp .env.example .env
  # Edit .env with your credentials, then run:
  asn-updater

IMPORTANT - bgp.tools Fair Use:
  - You MUST set a descriptive User-Agent to identify yourself
  - Default or generic user agents may be blocked
  - Do NOT scrape HTML pages - use API endpoints only
  - See: https://bgp.tools/kb/api
`);
}

/**
 * Main function to update Firewalla target lists with ASN prefixes
 */
async function main() {
  // Parse command-line arguments
  const { dryRun, help } = parseArguments();

  // Show help and exit if requested
  if (help) {
    showHelp();
    process.exit(0);
  }

  // Configuration
  const mspDomain = process.env.MSP_DOMAIN;
  const token = process.env.FIREWALLA_TOKEN;
  const bgpToolsUserAgent = process.env.BGP_TOOLS_USER_AGENT;

  if (!mspDomain) {
    console.error('Error: MSP_DOMAIN environment variable is required');
    console.error('Example: MSP_DOMAIN=mydomain.firewalla.net');
    console.error('You can also set this in a .env file');
    process.exit(1);
  }

  if (!token) {
    console.error('Error: FIREWALLA_TOKEN environment variable is required');
    console.error('Set your personal access token');
    console.error('You can also set this in a .env file');
    process.exit(1);
  }

  if (!bgpToolsUserAgent) {
    console.error('Error: BGP_TOOLS_USER_AGENT environment variable is required');
    console.error('');
    console.error('bgp.tools requires a descriptive user agent to identify yourself.');
    console.error('Format: "organization bgp.tools - contact@email.com"');
    console.error('Example: BGP_TOOLS_USER_AGENT="acmeco bgp.tools - contact@acme.co"');
    console.error('');
    console.error('You can set this in a .env file');
    process.exit(1);
  }

  console.log('=== Firewalla ASN Target List Updater ===');
  console.log(`MSP Domain: ${mspDomain}`);
  console.log(`Dry run: ${dryRun ? 'YES' : 'NO'}`);
  console.log('');
  console.log('=== FAIR USE NOTICE ===');
  console.log('bgp.tools API Requirements:');
  console.log('- You MUST use a descriptive User-Agent to identify yourself');
  console.log('- Default or generic user agents may be blocked');
  console.log('- Preferred format: "organization bgp.tools - contact@email.com"');
  console.log('- Do NOT scrape HTML pages - use the API endpoints only');
  console.log('- See: https://bgp.tools/kb/api');
  console.log('');

  try {
    // Fetch all boxes in the account
    console.log('Fetching Firewalla boxes...');
    const boxes = await fetchBoxes(mspDomain, token);
    console.log(`Found ${boxes.length} box(es)\n`);

    // Build list of owners to check: global + each box
    const owners = ['global', ...boxes.map((box) => box.gid)];

    // Fetch target lists for all owners
    console.log('Fetching target lists for all owners...');
    const allTargetListsPromises = owners.map((owner) => fetchTargetLists(mspDomain, token, owner));
    const allTargetListsResults = await Promise.all(allTargetListsPromises);

    // Combine and deduplicate target lists by ID
    const targetListsMap = new Map<string, TargetList>();
    for (const lists of allTargetListsResults) {
      for (const list of lists) {
        targetListsMap.set(list.id, list);
      }
    }

    const targetLists = Array.from(targetListsMap.values());
    console.log(`Found ${targetLists.length} unique target list(s) across all owners\n`);

    // Download BGP table and ASNs data once for all ASNs
    console.log('Downloading BGP table data...');
    const bgpTableData = await downloadBGPTable();
    console.log('BGP table data ready\n');

    console.log('Downloading ASNs metadata...');
    const asnsData = await downloadASNsData();
    console.log('ASNs metadata ready\n');

    let updatedCount = 0;
    let skippedCount = 0;

    // Process each target list
    for (const list of targetLists) {
      const asns = parseASNsFromName(list.name);

      if (asns.length === 0) {
        skippedCount++;
        continue;
      }

      console.log(`\nProcessing: "${list.name}" (ID: ${list.id}, Owner: ${list.owner})`);
      console.log(`  Found ASNs: ${asns.map((asn) => `AS${asn}`).join(', ')}`);

      // Fetch prefixes for all ASNs concurrently
      if (bgpTableData === null) {
        console.log('  ⚠ Unable to download BGP table data, skipping update');
        skippedCount++;
        continue;
      }
      const prefixPromises = asns.map((asn) => fetchPrefixesForASN(asn, bgpTableData, asnsData));
      const asnInfoResults = await Promise.all(prefixPromises);

      // Combine results
      const allPrefixes: string[] = [];
      const asnMetadata: string[] = [];

      for (const asnInfo of asnInfoResults) {
        allPrefixes.push(...asnInfo.prefixes);
        asnMetadata.push(`AS${asnInfo.asn}: ${asnInfo.prefixes.length} prefixes`);
      }

      // Remove duplicates
      const uniquePrefixes = [...new Set(allPrefixes)];
      console.log(`  Total unique prefixes: ${uniquePrefixes.length}`);

      if (uniquePrefixes.length === 0) {
        console.log('  ⚠ No prefixes found, skipping update');
        skippedCount++;
        continue;
      }

      // Generate metadata notes with organization info
      const timestamp = new Date().toISOString();
      const asnList = asnInfoResults
        .map((info) => `- AS${info.asn} (${info.orgName}, ${info.countryCode})`)
        .join('\n');

      // Preserve user comments from existing notes
      const userComments = extractUserComments(list.notes);

      const autoGeneratedContent = `${AUTO_COMMENT_START}
Auto-updated by Firewalla ASN Updater
Last updated: ${timestamp}
ASNs: 
${asnList}
${asnMetadata.join('\n')}
Total IP ranges: ${uniquePrefixes.length}
${AUTO_COMMENT_END}`;

      // Combine user comments with auto-generated content, prioritizing user comments
      const finalNotes = combineNotesWithPriority(userComments, autoGeneratedContent);

      // Update the target list
      if (dryRun) {
        console.log('  [DRY RUN] Would update with:');
        console.log(`    ${uniquePrefixes.length} IP ranges`);
        console.log(`    First few: ${uniquePrefixes.slice(0, 3).join(', ')}...`);
      } else {
        await updateTargetList(mspDomain, token, list.id, uniquePrefixes, finalNotes);
        updatedCount++;
      }
    }

    // Summary
    console.log('\n=== Summary ===');
    console.log(`Firewalla boxes: ${boxes.length}`);
    console.log(`Total target lists checked: ${targetLists.length}`);
    console.log(`Updated: ${updatedCount}`);
    console.log(`Skipped (no ASNs): ${skippedCount}`);

    if (dryRun) {
      console.log('\n*** DRY RUN MODE - No changes were made ***');
    }
  } catch (error) {
    console.error('\n=== Fatal Error ===');
    if (axios.isAxiosError(error)) {
      console.error('Network Error:');
      if (error.response) {
        console.error(`  Status: ${error.response.status} ${error.response.statusText}`);
        console.error(`  URL: ${error.config?.url}`);
        if (error.response.data) {
          console.error(`  Response: ${JSON.stringify(error.response.data).substring(0, 200)}`);
        }
      } else if (error.request) {
        console.error('  No response received from server');
        console.error(`  URL: ${error.config?.url}`);
      } else {
        console.error(`  ${error.message}`);
      }
    } else if (error instanceof Error) {
      console.error(`Error: ${error.message}`);
      if (error.stack) {
        console.error('Stack trace:');
        console.error(error.stack);
      }
    } else {
      console.error('Unknown error:', error);
    }
    process.exit(1);
  }
}

// Run main function
if (require.main === module) {
  main().catch((error) => {
    console.error('Fatal error:', error);
    process.exit(1);
  });
}

export {
  parseASNsFromName,
  extractUserComments,
  truncateNotes,
  combineNotesWithPriority,
  fetchPrefixesForASN,
  fetchBoxes,
  fetchTargetLists,
  updateTargetList,
};
